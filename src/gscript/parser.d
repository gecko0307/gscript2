/*
Copyright (c) 2014-2024 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module gscript.parser;

import core.stdc.stdlib;
import std.stdio;
import std.ascii;
import std.process;
import std.file;
import std.path;
import std.conv;
import std.array;
import std.format;
import std.algorithm;

import gscript.lexer;
import gscript.expression;
import gscript.statement;
import gscript.dynamic;
import gscript.program;

string moduleToPath(string modulename, string ext)
{
    string fname = modulename;
    fname = replace(fname, ".", "/");
    fname = fname ~ ext;
    return fname;
}

string pathToModule(string path)
{
    string mdl = path.stripExtension();
    mdl = replace(mdl, "/", ".");
    return mdl;	
}

struct Context
{
    BlockStatement block;
    Expression variable;
    
    auto foreachStatement()
    {
        return cast(ForeachStatement)block;
    }
}

class Parser
{
   public:
    string filename;
    string moduleName;
    string srcExt;

    string listing;
    Lexer lex;

    Program prog;

   protected:
    Module modul;
    FunctionStatement currentFunc;
    bool lvalue = false;

   public:
    this(Program prog, string listing, string srcExt = ".gs", string filename = "<undefined>")
    {
        this.prog = prog;
        this.listing = listing;
        this.srcExt = srcExt;
        this.filename = filename;
        this.moduleName = pathToModule(filename);
    }

    Lexer createLexer(string text)
    {
        return new Lexer(text);
    }

    void error(string message)
    {
        writefln("%s(%s): %s", filename, lex.line, message);
        core.stdc.stdlib.exit(1);
    }

    Module moduleTree()
    {
        modul = new Module(moduleName);

        prog.modules[moduleName] = modul;

        lex = createLexer(listing);
        lex.readNext();
        parseFunctionPrototypes();

        lex = createLexer(listing);
        lex.readNext();
        parseModule();

        return modul;
    }

   protected:

    bool isFunction(string token)
    {
        if (isIdentifier(token))
        {
            if (prog.hasHostFunction(token) ||
                modul.hasLocalFunction(token) || 
                modul.hasImportedFunction(token) || 
                modul.hasQualifiedImportFunction(token) ||
                token == currentFunc.name ||
                token.startsWith("host.") ||
                token == "self")
                return true;
            else
                return false;
        }
        else
            return false;
    }

   /*
    * Terminate statement
    */
    void term()
    {
        if (lex.current == ";")
            lex.readNext();
        else
        {
            string wrong = lex.current;
            if (lex.current == "")
                wrong = "EOF";
            error("Expected \";\" at the end of statement, not \"" ~ wrong ~ "\"");
        }
    }

   /*
    * Parse function headers only and fill in the function table
    */
    void parseFunctionPrototypes()
    {
        string token = lex.current;
        while(token != "")
        {
            FunctionStatement f = parseFunctionPrototype(Context(modul));
            if (f !is null)
            {
                modul.functions[f.name] = f;
            }
            token = lex.current;
        }
    }

    FunctionStatement parseFunctionPrototype(Context context)
    {
        FunctionStatement res;
        bool reading;
        do
        {
            reading = true;

            if (lex.current == "func" || lex.current == "prototype")
            {
                lex.readNext(); 

                //string funcName;
                if (isIdentifier(lex.current) && isValidName(lex.current))
                {
                    res = new FunctionStatement();

                    string funcName = lex.current;
                    lex.readNext(); // pop function name

                    if (modul.hasLocalFunction(funcName))
                        error("Function \"" ~ funcName ~ "\" already exists");

                    res.name = funcName;

                    res.qualifiedName = modul.qualifiedFunctionName(funcName);

                    FunctionArgListStatement funcArgs;
                    if (lex.current == "(")
                    {
                        lex.readNext(); // pop left parenthesis
                        funcArgs = parseArgList(context);
                        if (lex.current != ")")
                            error("Closing parenthesis expected, not \"" ~ lex.current ~ "\"");
                        lex.readNext(); // pop right parenthesis
                    }
                    else
                        error("Argument list expected, not \"" ~ lex.current ~ "\"");

                    res.args = funcArgs;
                }
                //else funcName = "__lambda_" ~ res.id;
                    //continue;
                    //error("Function name expected, not \"" ~ lex.current ~ "\"");

                reading = false;
            }
            else
            {
                if (lex.current == "")
                    reading = false;
                else
                    lex.readNext(); 
            }
        }
        while(reading);
        return res;
    }

   /*
    * Parse all code in the module
    */
    void parseModule()
    {
        string token = lex.current;
        while(token != "")
        {
            if (token == "func")
            {
                FunctionStatement f = parseFunction(Context(modul));
            }
            else if (token == "prototype")
            {
                FunctionStatement f = parsePrototypeFunction(Context(modul));
            }
            else if (token == "import")
            {
                lex.readNext(); // pop import
                string importName = lex.current;
                importName = importName[1..$-1];

                if (!(importName in prog.modules)) // to prevent cyclic dependency
                {
                    string fname = importName; //moduleToPath(importName, srcExt);

                    if (!exists(fname))
                    {
                        bool foundModule = false;
                        foreach(dir; prog.importDirs)
                        {
                            string fname2 = dir ~ fname;
                            if (exists(fname2))
                            {
                                foundModule = true;
                                fname = fname2;
                                break;
                            }
                        }

                        if (!foundModule)
                            error("Cannot find module \"" ~ importName ~ "\"");
                    }

                    string t = readText(fname);
                    Parser parser = new Parser(prog, t, srcExt, fname);

                    auto impModule = parser.moduleTree;
                    modul.imports[importName] = impModule;
                }
                else
                {
                    modul.imports[importName] = prog.modules[importName];
                }

                lex.readNext(); // pop name
                term();
            }
            else
                error("Declaration expected, not \"" ~ token ~ "\"");
            token = lex.current;
        }
    }

   /*
    * Parse function declaration
    */
    FunctionStatement parseFunction(Context context)
    {
        if (lex.current != "func")
            error("Function expected, not \"" ~ lex.current ~ "\"");

        lex.readNext();

        string funcName;
        if (isIdentifier(lex.current) && isValidName(lex.current))
        {
            funcName = lex.current;
            lex.readNext(); // pop function name
        }
        else
            error("Function name expected, not \"" ~ lex.current ~ "\"");

        FunctionStatement result = modul.functions[funcName];
        currentFunc = result;

        result.name = funcName;
        result.qualifiedName = modul.qualifiedFunctionName(funcName);

        FunctionArgListStatement funcArgs;
        if (lex.current == "(")
        {
            lex.readNext(); // pop left parenthesis
            funcArgs = parseArgList(context);
            if (lex.current != ")")
                error("Closing parenthesis expected, not \"" ~ lex.current ~ "\"");
            lex.readNext(); // pop right parenthesis
        }
        else
            error("Argument list expected, not \"" ~ lex.current ~ "\"");
        result.args = funcArgs;

        auto funcBody = parseFunctionBody(context);
        result.fbody = funcBody;

        return result;
    }
    
   /*
    * Parse prototype function declaration
    */
    FunctionStatement parsePrototypeFunction(Context context)
    {
        if (lex.current != "prototype")
            error("Prototype function expected, not \"" ~ lex.current ~ "\"");
        
        lex.readNext();
        
        string funcName;
        if (isIdentifier(lex.current) && isValidName(lex.current))
        {
            funcName = lex.current;
            lex.readNext(); // pop function name
        }
        else
            error("Function name expected, not \"" ~ lex.current ~ "\"");
        
        FunctionStatement result = modul.functions[funcName];
        currentFunc = result;

        result.isPrototype = true;
        result.name = funcName;
        result.qualifiedName = modul.qualifiedFunctionName(funcName);

        FunctionArgListStatement funcArgs;
        if (lex.current == "(")
        {
            lex.readNext(); // pop left parenthesis
            funcArgs = parseArgList(context);
            if (lex.current != ")")
                error("Closing parenthesis expected, not \"" ~ lex.current ~ "\"");
            lex.readNext(); // pop right parenthesis
        }
        else
            error("Argument list expected, not \"" ~ lex.current ~ "\"");
        result.args = funcArgs;
        
        //string thisFullName = "this"; //funcBody.localVariable("this");
        //writeln(thisFullName);
        //result.addVariable(thisFullName);
        
        auto funcBody = cast(BlockStatement)parseFunctionBody(context, ["this"]);
        result.fbody = funcBody;
        
        //funcBody.addChild(new VarDeclareStatement("this", result.address[thisFullName], null));
        
        string thisFullName = funcBody.localVariable("this");
        Expression returnExpr = new VariableRefExpression(thisFullName, result.address[thisFullName]);
        ReturnStatement implicitReturn = new ReturnStatement(funcBody, returnExpr);
        funcBody.addChild(implicitReturn);

        return result;
    }

    FunctionArgListStatement parseArgList(Context context)
    {
        auto list = new FunctionArgListStatement();

        bool readingList;
        do
        {
            readingList = true;

            string name = lex.current;

            if (name == ")")
            {
                break;
            }

            lex.readNext();

            if (isIdentifier(name) && isValidName(name))
            {
                list.addArgument(name);

                if (lex.current != ",")
                    readingList = false;
                else
                    lex.readNext();
            }
            else
                error("Identifier expected, not \"" ~ name ~ "\"");
        }
        while(readingList);

        return list;
    }

    Statement parseFunctionBody(Context context, string[] implicitVariables = [])
    {
        BlockStatement block = new BlockStatement(context.block);
        
        foreach(name; implicitVariables)
        {
            block.variables[name] = name;
            string fullName = block.localVariable(name);
            currentFunc.addVariable(fullName);
            block.addChild(new VarDeclareStatement(name, currentFunc.address[fullName], null));
        }
        
        if (lex.current == "{")
        {
            lex.readNext(); // pop {
            if (lex.current != "}")
            {
                while(lex.current != "}")
                {
                    Statement s = parseStatement(Context(block));
                    block.addChild(s);
                }
            }
            lex.readNext(); // pop }
        }
        
        return block;
    }

   /*
    * Parse code block
    */
    Statement parseBlock(Context context)
    {
        Statement result;

        string token = lex.current;

        if (token == "{")
        {
            BlockStatement block = new BlockStatement(context.block);
            lex.readNext(); // pop {
            if (lex.current != "}")
            {
                while(token != "}")
                {
                    Statement s = parseStatement(Context(block));
                    block.addChild(s);
                    token = lex.current;
                }
            }
            lex.readNext(); // pop }
            result = block;
        }
        else
        {
            result = parseStatement(context);
        }

        return result;
    }

   /*
    * Parse statement: 
    * "if...else", "while", "do...while", "return",
    * "break", "continue", "var", assignment, procedure call
    */
    Statement parseStatement(Context context)
    {
        Statement result;

        string token = lex.current;

        if (token == "if")
        {
            lex.readNext(); // pop "if"
            Expression conditionExpr = parseExpression(context);
            Statement ifStmt, elseStmt;
            ifStmt = parseBlock(context);

            if (lex.current == "else")
            {
                lex.readNext(); // pop "else"
                elseStmt = parseBlock(context);
            }

            result = new IfStatement(context.block, conditionExpr, ifStmt, elseStmt);
        }
        else if (token == "while")
        {
            lex.readNext(); // pop "while"
            Expression conditionExpr = parseExpression(context);
            WhileStatement whileStmt = new WhileStatement(context.block);
            Statement loopStmt = parseBlock(Context(whileStmt));
            whileStmt.condition = conditionExpr;
            whileStmt.loopStmt = loopStmt;
            result = whileStmt;
        }
        else if (token == "do")
        {
            lex.readNext(); // pop "do"
            DoWhileStatement doWhileStmt = new DoWhileStatement(context.block);
            Statement loopStmt = parseBlock(Context(doWhileStmt));
            if (lex.current != "while")
                error("\"while\" expected, not \"" ~ lex.current ~ "\"");
            lex.readNext(); // "while"
            Expression conditionExpr = parseExpression(context);
            term();
            doWhileStmt.condition = conditionExpr;
            doWhileStmt.loopStmt = loopStmt;
            result = doWhileStmt;
        }
        else if (token == "foreach")
        {
            lex.readNext(); // pop "foreach"
            ForeachStatement foreachStmt = new ForeachStatement(context.block);
            auto loopContext = Context(foreachStmt);
            Expression expr = parseExpression(loopContext);
            auto inExpr = cast(InExpression)expr;
            if (inExpr)
            {
                if (inExpr.iterExpr.chain.length != 2)
                {
                    error("Illegal \"in\" expression in \"foreach\"");
                }
            }
            else
                error("\"in\" expression expected");
            Statement loopStmt = parseBlock(loopContext);
            foreachStmt.inExpr = cast(InExpression)inExpr;
            foreachStmt.loopStmt = loopStmt;
            result = foreachStmt;
        }
        else if (token == "for")
        {
            lex.readNext(); // pop "for"
            ForStatement forStmr = parseForStatement(context);
            result = forStmr;
        }
        else if (token == "return")
        {
            lex.readNext(); // pop "return"
            Expression returnExpr = parseExpression(context);
            term();
            result = new ReturnStatement(context.block, returnExpr);
        }
        else if (token == "break")
        {
            lex.readNext(); // pop "break"
            if (!context.block.belongsToLoop)
                error("Unexpected \"break\"");
            term();
            result = new BreakStatement(context.block);
        }
        else if (token == "continue")
        {
            lex.readNext(); // pop "continue"
            if (!context.block.belongsToLoop)
                error("Unexpected \"continue\"");
            term();
            result = new ContinueStatement(context.block);
        }
        else if (token == "var")
        {
            lex.readNext(); // pop "var"
            result = declListExpr(context);
        }
        else if (isFunction(token)) // procedure call
        {
            result = parseProcCall(context);
        }
        else // member call or simple expression
        {
            Expression firstArgExpr = parseExpression(context);
            result = new ProcCallStatement(firstArgExpr);
            term();
        }

        return result;
    }

   /*
    * Parse variable declaration list
    */
    MultVarDeclareStatement declListExpr(Context context)
    {
        auto list = new MultVarDeclareStatement();

        bool readingList;
        do
        {
            readingList = true;

            string name = lex.current;
            lex.readNext(); // pop argument name
            
            if (!isIdentifier(name) || !isValidName(name))
                error("\"" ~ name ~ "\" cannot be used as a variable name");

            if (name in context.block.variables)
                error("Variable \"" ~ name ~ "\" already exists");

            if (currentFunc.argExists(name))
                error("Variable \"" ~ name ~ "\" shadows function argument \"" ~ name ~ "\"");

            Expression initExpr;
            if (lex.current == "=")
            {
                lex.readNext();
                initExpr = parseExpression(context);
            }
            else
                initExpr = null;

            string fullName = context.block.localVariable(name);

            if (!currentFunc.argExists(name))
                currentFunc.addVariable(fullName);
            else
                error("Variable \"" ~ name ~ "\" conflicts with function argument \"" ~ name ~ "\"");

            context.block.variables[name] = name;

            list.addChild(new VarDeclareStatement(name, currentFunc.address[fullName], initExpr));

            if (lex.current != ",")
                readingList = false;
            else
                lex.readNext();
        }
        while(readingList);

        term();

        return list;
    }
    
    ChainExpression parseDeclListExpr(Context context)
    {
        ChainExpression result = new ChainExpression();
        bool readingList;
        do
        {
            readingList = true;

            string name = lex.current;
            lex.readNext(); // pop argument name
            
            if (!isIdentifier(name) || !isValidName(name))
                error("\"" ~ name ~ "\" cannot be used as a variable name");

            string fullName = context.block.localVariable(name);

            if (!currentFunc.argExists(name))
                currentFunc.addVariable(fullName);
            else
                error("Variable \"" ~ name ~ "\" conflicts with function argument \"" ~ name ~ "\"");

            context.block.variables[name] = name;
            
            int address = currentFunc.address[context.block.variable(name)];
            result.chain ~= new VariableRefExpression(name, address);

            if (lex.current != ",")
                readingList = false;
            else
                lex.readNext();
        }
        while(readingList);

        return result;
    }

   /*
    * Parse procedure call statement
    */
    ProcCallStatement parseProcCall(Context context)
    {
        ProcCallStatement result;
        string funcName = lex.current;
        
        if (isFunction(funcName))
        {
            Expression e = parseExpression(context);
            term();
            result = new ProcCallStatement(e);
        }
        else
            error("Function expected, not \"" ~ funcName ~ "\"");
            
        return result;
    }

   /*
    * Parse for statement
    */
    ForStatement parseForStatement(Context context)
    {
        //writeln("parseForStatement");
        ForStatement forStmt = new ForStatement(context.block);

        if (lex.current != "(")
            error("Left bracket expected, not \"" ~ lex.current ~ "\"");

        lex.readNext(); // pop left parenthesis

        ChainExpression initExpr = new ChainExpression();
        while(lex.current != ";")
        {
            //writeln("initExpr");
            initExpr.chain ~= parseExpression(Context(forStmt));
            if (lex.current == ",")
                lex.readNext(); // pop ","
        }
        lex.readNext(); // pop ";"

        ChainExpression conditionExpr = new ChainExpression();
        while(lex.current != ";")
        {
            conditionExpr.chain ~= parseExpression(Context(forStmt));
            if (lex.current == ",")
                lex.readNext(); // pop ","
        }
        lex.readNext(); // pop ";"

        ChainExpression nextExpr = new ChainExpression();
        while(lex.current != ")")
        {
            nextExpr.chain ~= parseExpression(Context(forStmt));
            if (lex.current == ",")
                lex.readNext(); // pop ","
        }
        lex.readNext(); // pop right parenthesis

        Statement loopStmt = parseBlock(Context(forStmt));

        forStmt.initExpr = initExpr;
        forStmt.conditionExpr = conditionExpr;
        forStmt.nextExpr = nextExpr;
        forStmt.loopStmt = loopStmt;
        return forStmt;
    }

   /*
    * Base entry for expression parsing
    */
    Expression parseExpression(Context context)
    {
        Expression result = parseAssignExpression(context);

        if (lex.current == "~")
        {
            lex.readNext();
            result = new BinaryOpExpression("~", result, parseExpression(context));
        }

        return result;
    }

    Expression parseAssignExpression(Context context)
    {
        Expression result;
        
        result = parseInExpression(context);
        
        if (lex.current == "=")
        {
            lex.readNext();
            result = new BinaryOpExpression("assign", result, parseAssignExpression(context));
        }
        else if (isAssignment(lex.current))
        {
            string op = lex.current;
            lex.readNext();
            result = new BinaryOpExpression(op, result, parseAssignExpression(context));
        }

        return result;
    }
    
    Expression parseInExpression(Context context)
    {
        Expression result = parseLogicalExpression(context);

        if (lex.current == "in")
        {
            lex.readNext();
            
            auto chainExpr = cast(ChainExpression)result;
            if (chainExpr !is null)
            {
                if (chainExpr.chain.length == 0)
                    error("Declaration is empty");
                else if (chainExpr.chain.length == 1)
                {
                    string indexVarName = "__i" ~ chainExpr.chain[0].id;
                    string indexFullName = context.block.localVariable(indexVarName);
                    currentFunc.addVariable(indexFullName);
                    context.block.variables[indexVarName] = indexVarName;
                    int address = currentFunc.address[context.block.variable(indexVarName)];
                    auto varExpr = new VariableRefExpression(indexVarName, address);
        
                    chainExpr.chain = varExpr ~ chainExpr.chain;
                }
                else if (chainExpr.chain.length > 2)
                    error("Wrong number of operands for \"in\" operator");
            }
            else
            {
                chainExpr = new ChainExpression([result]);
            }

            auto arrayEvalExpr = parseInExpression(context);

            string arrayVarName = "__a" ~ arrayEvalExpr.id;
            string arrayFullName = context.block.localVariable(arrayVarName);
            currentFunc.addVariable(arrayFullName);
            context.block.variables[arrayVarName] = arrayVarName;
            int address = currentFunc.address[context.block.variable(arrayVarName)];
            auto arrayVarExpr = new VariableRefExpression(arrayVarName, address);
        
            result = new InExpression(arrayEvalExpr, chainExpr, arrayVarExpr);
        }

        return result;
    }

    Expression parseLogicalExpression(Context context)
    {
        Expression result = parseBitwiseExpression(context);

        bool replaced;
        do
        {
            replaced = false;
            string token = lex.current;

            if (token == "&&" || token == "and")
            {
                lex.readNext();
                result = new BinaryOpExpression("&&", result, parseBitwiseExpression(context));
                replaced = true;
            }
            else if (token == "||" || token == "or")
            {
                lex.readNext();
                result = new BinaryOpExpression("||", result, parseBitwiseExpression(context));
                replaced = true;
            }
        }
        while(replaced);

        return result;
    }

    Expression parseBitwiseExpression(Context context)
    {
        Expression result = parseCompareExpression(context);

        bool replaced;
        do
        {
            replaced = false;
            string token = lex.current;

            if (token == "&")
            {
                lex.readNext();
                result = new BinaryOpExpression("&", result, parseCompareExpression(context));
                replaced = true;
            }
            else if (token == "|")
            {
                lex.readNext();
                result = new BinaryOpExpression("|", result, parseCompareExpression(context));
                replaced = true;
            }
            else if (token == "xor")
            {
                lex.readNext();
                result = new BinaryOpExpression("xor", result, parseCompareExpression(context));
                replaced = true;
            }
        }
        while(replaced);

        return result;
    }

    Expression parseCompareExpression(Context context)
    {
        Expression result = parseBitwiseShiftExpression(context);

        bool replaced;
        do
        {
            replaced = false;
            string token = lex.current;

            if (token == "<")
            {
                lex.readNext();
                result = new BinaryOpExpression("<", result, parseBitwiseShiftExpression(context));
                replaced = true;
            }
            else if (token == ">")
            {
                lex.readNext();
                result = new BinaryOpExpression(">", result, parseBitwiseShiftExpression(context));
                replaced = true;
            }
            else if (token == "==")
            {
                lex.readNext();
                result = new BinaryOpExpression("==", result, parseBitwiseShiftExpression(context));
                replaced = true;
            }
            else if (token == "!=")
            {
                lex.readNext();
                result = new BinaryOpExpression("!=", result, parseBitwiseShiftExpression(context));
                replaced = true;
            }
            else if (token == "<=")
            {
                lex.readNext();
                result = new BinaryOpExpression("<=", result, parseBitwiseShiftExpression(context));
                replaced = true;
            }
            else if (token == ">=")
            {
                lex.readNext();
                result = new BinaryOpExpression(">=", result, parseBitwiseShiftExpression(context));
                replaced = true;
            }
            else if (token == "is")
            {
                lex.readNext();
                result = new BinaryOpExpression("is", result, parseBitwiseShiftExpression(context));
                replaced = true;
            }
            else if (token == "!" || token == "not")
            {
                lex.readNext();
                if (lex.current == "is")
                {
                    lex.readNext();
                    result = new UnaryOpExpression("!", new BinaryOpExpression("is", result, parseBitwiseShiftExpression(context)));
                    replaced = true;
                }
                else
                    error("Unexpected \"" ~ lex.current ~ "\" after \"" ~ token ~ "\"");
            }
        }
        while(replaced);

        return result;
    }

    Expression parseBitwiseShiftExpression(Context context)
    {
        Expression result = parseAddSubExpression(context);

        bool replaced;
        do
        {
            replaced = false;
            string token = lex.current;

            if (token == ">>")
            {
                lex.readNext();
                result = new BinaryOpExpression(">>", result, parseAddSubExpression(context));
                replaced = true;
            }
            else if (token == "<<")
            {
                lex.readNext();
                result = new BinaryOpExpression("<<", result, parseAddSubExpression(context));
                replaced = true;
            }
        }
        while(replaced);

        return result;
    }

    Expression parseAddSubExpression(Context context)
    {
        Expression result = parseMulDivExpression(context);

        bool replaced;
        do
        {
            replaced = false;
            string token = lex.current;

            if (token == "+")
            {
                lex.readNext();
                result = new BinaryOpExpression("+", result, parseMulDivExpression(context));
                replaced = true;
            }
            else if (token == "-")
            {
                lex.readNext();
                result = new BinaryOpExpression("-", result, parseMulDivExpression(context));
                replaced = true;
            }
        }
        while(replaced);

        return result;
    }

    Expression parseMulDivExpression(Context context)
    {
        Expression result = parseUnaryOpExpression(context);

        bool replaced;
        do
        {
            replaced = false;
            string token = lex.current;
            if (token == "*")
            {
                lex.readNext();
                result = new BinaryOpExpression("*", result, parseUnaryOpExpression(context));
                replaced = true;
            }
            else if (token == "/")
            {
                lex.readNext();
                result = new BinaryOpExpression("/", result, parseUnaryOpExpression(context));
                replaced = true;
            }
            else if (token == "mod")
            {
                lex.readNext();
                result = new BinaryOpExpression("mod", result, parseUnaryOpExpression(context));
                replaced = true;
            }
            else if (token == "^")
            {
                lex.readNext();
                result = new BinaryOpExpression("^", result, parseUnaryOpExpression(context));
                replaced = true;
            }
            else if (token == ":")
            {
                lex.readNext();
                result = parseMemberCallExpression(context, result);
                replaced = true;
            }
            else if (token == "%")
            {
                lex.readNext();
                result = parseSubstitutionExpression(context, result);
                replaced = true;
            }
        }
        while(replaced);

        if (result is null)
            result = parseUnaryOpExpression(context);

        return result;
    }

    Expression parseUnaryOpExpression(Context context)
    {
        Expression result;

        string token = lex.current;

        if (token == "-")
        {
            lex.readNext();
            result = new UnaryOpExpression("UMINUS", parseUnaryOpExpression(context));
        }
        else if (token == "+")
        {
            lex.readNext();
            result = new UnaryOpExpression("UPLUS", parseUnaryOpExpression(context));
        }
        else if (token == "!" || token == "not")
        {
            lex.readNext();
            result = new UnaryOpExpression("!", parseUnaryOpExpression(context));
        }
        else
        {
            result = parseSymbolExpression(context, token);
        }

        return result;
    }

    Expression parseMemberCallExpression(Context context, Expression e = null)
    {
        Expression result;
        string funcName = lex.current;
        if (isFunction(funcName))
        {
            lex.readNext();
            ListExpression list;
            if (lex.current == "(")
            {
                lex.readNext(); // pop left parenthesis
                if (lex.current != ")")
                    list = parseListExpression(context, e);
                else
                    list = new ListExpression(e);
                result = parseFunctionCallExpression(context, funcName, list);
                lex.readNext(); // pop right parenthesis
            }
            else
            {
                list = new ListExpression(e);
                result = parseFunctionCallExpression(context, funcName, list);
            }
        }
        else
            error("Undefined function \"" ~ funcName ~ "\"");
        return result;
    }

    Expression parseSubstitutionExpression(Context context, Expression e)
    {
        Expression result;
        ListExpression list;
        if (lex.current == "(")
        {
            lex.readNext(); // pop left parenthesis
            if (lex.current != ")")
                list = parseListExpression(context, e);
            else
            {
                list = new ListExpression(e);
            }
            lex.readNext(); // pop right parenthesis
            result = new BuiltInFunctionCallExpression("format", list); 
            //result = parseFunctionCallExpression(context, "host.format", list);
        }
        else
        {
            list = new ListExpression([e] ~ parseExpression(context));
            result = new BuiltInFunctionCallExpression("format", list);
            //writeln(lex.current);
            //result = parseFunctionCallExpression(context, "host.format", list);
        }
        return result;
    }

    Expression parseIndexExpression(Context context)
    {
        auto result = new ChainExpression();
        bool readingIndices = true;
        bool inBrackets = false;

        Expression[] chain2;
        chain2 ~= context.variable;

        while(readingIndices)
        {
            if (lex.current == "[")
            {
                inBrackets = true;
                lex.readNext(); // pop left bracket

                if (lex.current != "]")
                {
                    auto varExpr = new ChainExpression(chain2);
                    auto ind = new IndexExpression(parseExpression(Context(context.block, varExpr)));
                    result.chain ~= ind;
                    chain2 ~= ind;
                }
                else
                    error("Index cannot be empty");
            }
            else if (lex.current == "]")
            {
                if (!inBrackets)
                    error("Illegal square bracket");

                inBrackets = false;
                lex.readNext(); // pop right bracket
            }
            else if (lex.current == ",")
            {
                if (inBrackets)
                {
                    lex.readNext(); // pop comma
                    auto varExpr = new ChainExpression(chain2);
                    auto ind = new IndexExpression(parseExpression(Context(context.block, varExpr)));
                    result.chain ~= ind;
                    chain2 ~= ind;
                }
                else
                    readingIndices = false;
            }
            else
            {
                if (inBrackets)
                    error("Closing square bracket expected in index expression");

                readingIndices = false;
            }
        }

        return result;
    }

    Expression parseSymbolExpression(Context context, string token)
    {
        Expression result;
        if (token.isNumber || token.isString || token.isBoolean || token == "null" || token == "global")
        {
            lex.readNext();
            if (isAssignment(lex.current))
                error("Cannot assign a value to a literal");
            else
            {
                string val;
                if (token.isString)
                    val = parseEscapeCharacters(token);
                else if (token.isBoolean)
                    val = booleanValue(token);
                else
                    val = token;
                result = new LiteralExpression(val);
            }
            
            if (token == "global")
            {
                result = parseAccessExpression(context, result);
            }
        }
        else if (token == "$")
        {
            if (context.variable)
            {
                lex.readNext();
                result = new DollarExpression(new LoadExpression(context.variable));
            }
            else
                error("Unexpected \"$\"");
            //assert(context.variable);
        }
        else if (token.isTypeIdentifier)
        {
            lex.readNext();
            if (isAssignment(lex.current))
                error("Cannot assign a value to \"" ~ token ~ "\"");
            else
                result = new LiteralExpression(typeIdentifier(token));
        }
        else if (token == "(")
        {
            lex.readNext(); // pop left parenthesis
            result = parseExpression(context);
            // TODO: make sure the next token is ")"
            lex.readNext(); // pop right parenthesis
        }
        else if (token == "[")
        {
            lex.readNext(); // pop left bracket
            if (lex.current != "]")
                result = new ArrayExpression(parseListExpression(context));
            else
                result = new ArrayExpression();
            lex.readNext(); // pop right bracket
        }
        else if (token == "var")
        {
            lex.readNext(); // pop "var"
            result = parseDeclListExpr(context);
        }
        else if (token == "func")
        {
            lex.readNext(); //pop "func"
            FunctionStatement f = parseClosure(Context(context.block));
            modul.functions[f.name] = f;
            result = new FunctionRefExpression(f.id.to!uint, cast(uint)f.args.names.length);
        }
        else if (token == "if")
        {
            lex.readNext(); //pop "if"
            auto conditionExpr = parseExpression(context);
            auto expr1 = parseExpression(context);
            if (lex.current != "else")
                error("\"else\" expected, not \"" ~ lex.current ~ "\"");
            lex.readNext(); //pop "else"
            auto expr2 = parseExpression(context);
            result = new InlineIfExpression(conditionExpr, expr1, expr2);
        }
        else if (token == "@")
        {
            lex.readNext(); //pop "@"
            string varName = lex.current;
            if (isIdentifier(varName))
            {
                lex.readNext(); //pop name
                
                int address;
                if (currentFunc.argExists(varName))
                {
                    address = currentFunc.args.address(varName);
                }
                else if (context.block.symbolIsVisible(varName))
                {
                    if (context.block.variable(varName) in currentFunc.address)
                        address = currentFunc.address[context.block.variable(varName)];
                    else
                        error("Illegal access to \"" ~ varName ~ "\"");
                }
                else
                    error("Undefined variable \"" ~ varName ~ "\"");
                
                auto varExpr = new VariableRefExpression(varName, address);
                auto accessExpr = parseAccessExpression(context, varExpr);
                result = new DereferenceExpression(accessExpr);
            }
            else
                error("Unexpected \"@\"");
        }
        else if (token == "ref")
        {
            lex.readNext(); //pop "ref"
            string name = lex.current;
            if (isFunction(name))
            {
                lex.readNext(); //pop name

                FunctionStatement func;
                //uint address;
                if (name == "self")
                    func = currentFunc;
                else if (modul.hasLocalFunction(name))
                    func = modul.functions[name];
                else if (modul.hasImportedFunction(name))
                    func = modul.importedFunction(name);
                else if (modul.hasQualifiedImportFunction(name))
                    func = modul.qualifiedImportedFunction(name);
                else
                    error("Cannot make a reference to non-script function \"" ~ name ~"\"");

                result = new FunctionRefExpression(func.id.to!uint, cast(uint)func.args.names.length);
            }
            else if (isIdentifier(name))
            {
                lex.readNext(); //pop name

                int address;
                if (context.block.symbolIsVisible(name))
                    address = currentFunc.address[context.block.variable(name)];
                else if (currentFunc.argExists(name))
                    address = currentFunc.args.address(name);
                else
                    error("Undefined identifier \"" ~ name ~ "\"");

                auto varExpr = new VariableRefExpression(name, address);
                Expression indexExpr;
                if (lex.current == "[")
                    indexExpr = parseIndexExpression(context);
                result = new RefExpression(varExpr, indexExpr);
            }
            else
                error("Cannot make a reference to \"" ~ lex.current ~ "\"");
        }
        else if (isFunction(token))
        { 
            string functionName = token;
            lex.readNext(); // pop function name
            if (lex.current == "(")
            {
                lex.readNext(); // pop left parenthesis
                if (lex.current != ")")
                {
                    result = parseFunctionCallExpression(context, functionName, parseListExpression(context));
                }
                else
                    result = parseFunctionCallExpression(context, functionName, new ListExpression());
                lex.readNext(); // pop right parenthesis
            }
            else
                result = parseFunctionCallExpression(context, functionName, new ListExpression());
                
            result = parseAccessExpression(context, result);
        }
        else if (isIdentifier(token)) // variable
        {
            string varName = token;
            lex.readNext(); // pop variable name

            //if (context.block.parent)
            //    writeln(context.block.parent.variables);

            int address;
            if (currentFunc.argExists(varName))
            {
                address = currentFunc.args.address(varName);
            }
            else if (context.block.symbolIsVisible(varName))
            {
                if (context.block.variable(varName) in currentFunc.address)
                    address = currentFunc.address[context.block.variable(varName)];
                else
                    error("Illegal access to \"" ~ varName ~ "\"");
            }
            else
                error("Undefined identifier \"" ~ varName ~ "\"");

            auto varExpr = new VariableRefExpression(varName, address);
            result = parseAccessExpression(context, varExpr);
        }
        else
            error("Unexpected token \"" ~ token ~ "\"");
        return result;
    }
    
    Expression parseAccessExpression(Context context, Expression leftExpr, Expression objExpr = null)
    {
        Expression result = leftExpr;
        string token = lex.current;
        
        //writeln(token);
        
        if (lex.current == "[")
        {
            Expression indexExpr = parseIndexExpression(context);
            result = parseAccessExpression(context, new RefExpression(leftExpr, indexExpr), leftExpr);
        }
        else if (lex.current == "(")
        {
            lex.readNext(); // pop left parenthesis
            if (lex.current != ")")
            {
                if (objExpr)
                    result = new ObjectCallExpression(leftExpr, parseListExpression(context, objExpr));
                else
                    result = new ObjectCallExpression(leftExpr, parseListExpression(context));
            }
            else
            {
                if (objExpr)
                    result = new ObjectCallExpression(leftExpr, new ListExpression(objExpr));
                else
                    result = new ObjectCallExpression(leftExpr, new ListExpression());
            }
            lex.readNext(); // pop right parenthesis
            result = parseAccessExpression(context, result, result);
        }
        else if (token == ".")
        {
            lex.readNext(); // pop dot
            Expression indexExpr = new IndexExpression(new LiteralExpression("\"" ~ lex.current ~ "\""));
            lex.readNext(); // pop identifier
            result = parseAccessExpression(context, new RefExpression(leftExpr, indexExpr), leftExpr);
        }
        
        return result;
    }

    ListExpression parseListExpression(Context context, Expression e = null)
    {
        Expression[] exprs;
        if (e)
            exprs ~= e;

        bool readingList;
        do
        {
            readingList = true;
            if (lex.current == "ref")
            {
                lex.readNext();
                string token = lex.current;
                exprs ~= parseRefExpression(context, token);
            }
            else
                exprs ~= parseExpression(context);

            if (lex.current != ",")
                readingList = false;
            else
                lex.readNext();
        }
        while(readingList);

        ListExpression result = new ListExpression(exprs);

        return result;
    }

    Expression parseRefExpression(Context context, string name)
    {
        Expression result;

        if (isFunction(name))
        {
            lex.readNext();
            
            FunctionStatement func;
            if (name == "self")
                func = currentFunc;
            else if (modul.hasLocalFunction(name))
                func = modul.functions[name];
            else if (modul.hasImportedFunction(name))
                func = modul.importedFunction(name);
            else if (modul.hasQualifiedImportFunction(name))
                func = modul.qualifiedImportedFunction(name);
            else
                error("Cannot make a reference to non-script function \"" ~ name ~"\"");

            result = new FunctionRefExpression(func.id.to!uint, cast(uint)func.args.names.length);
        }
        else if (isIdentifier(name))
        {
            lex.readNext();

            int address;
            if (context.block.symbolIsVisible(name))
                address = currentFunc.address[context.block.variable(name)];
            else if (currentFunc.argExists(name))
                address = currentFunc.args.address(name);
            else
                error("Cannot make a reference to \"" ~ name ~ "\"");

            auto varExpr = new VariableRefExpression(name, address);
            Expression indexExpr;
            if (lex.current == "[")
                indexExpr = parseIndexExpression(context);
            result = new RefExpression(varExpr, indexExpr); 

            if (lex.current != "," && lex.current != ")")
                error("Comma or closing bracket expected after \"" ~ name ~ "\", not \"" ~ lex.current ~ "\"");
        }
        else
            error("Identifier expected after \"ref\", not \"" ~ name ~ "\"");

        return result;
    }

    FunctionCallExpression parseFunctionCallExpression(Context context, string name, ListExpression list, Expression callee = null)
    {
        if (name == "")
        {
            return new ObjectCallExpression(callee, list);
        }
        else if (name == "self")
        {
            uint argsNum = cast(uint)currentFunc.args.names.length;

            if (list.children.length != argsNum)
                if (list.children.length == 0 || argsNum != 1)
                    error("Wrong number of arguments for function \"" ~ currentFunc.name ~ "\"");

            return new ScriptFunctionCallExpression(currentFunc.id.to!uint, list, argsNum);
        }
        else if (modul.hasLocalFunction(name)) // local function
        {
            uint argsNum = cast(uint)modul.functions[name].args.names.length;

            if (list.children.length != argsNum)
                if (list.children.length == 0 || argsNum != 1)
                    error("Wrong number of arguments for function \"" ~ name ~ "\"");

            return new ScriptFunctionCallExpression(modul.functions[name].id.to!uint, list, argsNum);
        }
        else if (modul.hasImportedFunction(name)) // imported function
        {
            int funcs = modul.importedFunctions(name);
            if (funcs == 1)
            {
                string qname = modul.qualifiedImportedFunctionName(name);
                auto func = modul.importedFunction(name);

                uint argsNum = cast(uint)func.args.names.length;
                if (list.children.length != argsNum)
                    if (list.children.length == 0 || argsNum != 1)
                        error("Wrong number of arguments for function \"" ~ qname ~ "\"");

                return new ScriptFunctionCallExpression(func.id.to!uint, list, argsNum);
            }
            else if (funcs > 1)
            {
                error("Calling function \"" ~ name ~ "\" is ambiguous");
            }
            else // should never get here
                assert(0);
        }
        else if (modul.hasQualifiedImportFunction(name)) // fully qualified imported function
        {
            auto func = modul.qualifiedImportedFunction(name);

            uint argsNum = cast(uint)func.args.names.length;
            if (list.children.length != argsNum)
                if (list.children.length == 0 || argsNum != 1)
                    error("Wrong number of arguments for function \"" ~ name ~ "\"");

            return new ScriptFunctionCallExpression(func.id.to!uint, list, argsNum);
        }
        else if (prog.hasHostFunction(name)) // built-in function
        {
            auto f = prog.hostFunctions[name];
            if (f.numArgs >= 0)
            {
                if (list.children.length != f.numArgs)
                    error("Wrong number of arguments for function \"host." ~ name ~ "\"");
            }
            return new BuiltInFunctionCallExpression(name, list);
        }
        /*
        else if (name.startsWith("host.")) // built-in function
        {
            if (name == "host.")
                error("Function name expected after \"host\"");

            string hostFuncName;
            formattedRead(name, "host.%s", &hostFuncName);

            if (prog.hasHostFunction(hostFuncName))
            {
                auto f = prog.hostFunctions[hostFuncName];
                if (f.numArgs >= 0)
                {
                    if (list.children.length != f.numArgs)
                        error("Wrong number of arguments for function \"" ~ name ~ "\"");
                }
                return new BuiltInFunctionCallExpression(hostFuncName, list);
            }
            else
                error("Undefined host function \"" ~ name ~ "\"");
        }
        */
        else if (context.block.symbolIsVisible(name))
        {
            auto address = currentFunc.address[context.block.variable(name)];
            return new ObjectCallExpression(new VariableRefExpression(name, address), list);
        }
        else if (currentFunc.argExists(name))
        {
            auto address = currentFunc.args.address(name);
            return new ObjectCallExpression(new VariableRefExpression(name, address), list);
        }
        else // should never get here
            assert(0);

        return null;
    }

   /*
    * Parse function declaration
    */
    FunctionStatement parseClosure(Context context)
    {
        FunctionStatement result = new FunctionStatement();

        result.name = "lambda" ~ result.id;
        result.qualifiedName = modul.qualifiedFunctionName(result.name);

        FunctionStatement prevFunc = currentFunc;
        currentFunc = result;

        FunctionArgListStatement funcArgs;
        if (lex.current == "(")
        {
            lex.readNext(); // pop left parenthesis
            funcArgs = parseArgList(context);
            if (lex.current != ")")
                error("Closing parenthesis expected, not \"" ~ lex.current ~ "\"");
            lex.readNext(); // pop right parenthesis
        }
        else
            error("Argument list expected, not \"" ~ lex.current ~ "\"");
        result.args = funcArgs;

        //TODO: allow access to enclosing function vars
        auto funcBody = parseFunctionBody(context); //Context(modul)
        result.fbody = funcBody;

        currentFunc = prevFunc;

        return result;
    }

    string parseEscapeCharacters(string s)
    {
        string res;
        bool expectCode = false;
        foreach(c; s)
        {
            if (expectCode)
            {
                if (c == 'n')
                    res ~= '\n';
                else if (c == '\\')
                    res ~= '\\';
                else
                    error("Illegal escape character \"\\" ~ c ~ "\"");
                expectCode = false;
            }
            else
            {
                if (c == '\\')
                    expectCode = true;
                else
                    res ~= c;
            }
        }
        return res;
    }
}

bool isNumber(string s)
{
    if (!s.length)
        return false;
    if (!isDigit(s[0]) && s[0] != '-')
        return false;
    bool haveDot = false;
    foreach(i, c; s)
    {
        if (c == '.')
        {
            if (haveDot)
                return false;
            else
                haveDot = true;
        }
        else if (c == '-')
        {
            if (i != 0)
                return false;
        }
        else if (!isDigit(c))
            return false;
    }
    return true;
}

bool isIdentifier(string s)
{
    return (s.length && (isAlpha(s[0]) || s[0] == '_'));
}

bool isValidName(string s)
{
    // TODO: instructions
    switch (s)
    {
        case "and", "break", "continue", "do", "else", "for", "foreach", "func", "prototype",
             "if", "import", "in", "is", "not", "or", "self", "ref", "return", "var", "while",
             "Float", "Array", "String", "Function",
             "true", "false", "null", "global",
             "new", "length", "assert", "array":
            return false;
        default:
            if (s.find('.').empty)
                return true;
            return false;
    }
}

bool isAssignment(string s)
{
    return (s == "=" || 
            s == "+=" ||
            s == "-=" ||
            s == "*=" ||
            s == "/=" ||
            s == "~=");
}

bool isTypeIdentifier(string s)
{
    return (s == "Float" ||
            s == "Array" ||
            s == "String" ||
            s == "Function" ||
            s == "Dictionary");
}

bool isBoolean(string s)
{
    return (s == "true" ||
            s == "false");
}

string booleanValue(string s)
{
    if (s == "true") return "1";
    else if (s == "false") return "0";
    else assert(0);
}

string typeIdentifier(string s)
{
    if (s == "Float") return "0";
    else if (s == "Array") return "1";
    else if (s == "String") return "2";
    else if (s == "Function") return "3";
    else if (s == "Dictionary") return "4";
    else assert(0);
}

bool isString(string s)
{
    return (s[0] == '\"' && s[$-1] == '\"');
}

