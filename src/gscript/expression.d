/*
Copyright (c) 2014-2020 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module gscript.expression;

import std.stdio;
import std.conv;

import gscript.ast;

abstract class Expression: ASTNode
{
}

class BinaryOpExpression: Expression
{
    string operator;

    this(string operator, Expression left, Expression right)
    {
        this.operator = operator;
        addChild(left);
        addChild(right);
    }

    override string[] postfixCode()
    {
        string[] res;
        foreach(c; children)
            res ~= c.postfixCode();
        res ~= operator;
        return res;
    }
}

class UnaryOpExpression: Expression
{
    string operator;

    this(string operator, Expression operand)
    {
        this.operator = operator;
        addChild(operand);
    }

    override string[] postfixCode()
    {
        string[] res;
        foreach(c; children)
            res ~= c.postfixCode();
        res ~= operator;
        return res;
    }
}

class LiteralExpression: Expression
{
    string operand;

    this(string operand)
    {
        this.operand = operand;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= "push " ~ operand;
        return res;
    }
}

class ListExpression: Expression
{
    this(Expression e = null)
    {
        if (e)
            addChild(e);
    }

    this(Expression[] elements)
    {
        foreach(e; elements)
            addChild(e);
    }

    override string[] postfixCode()
    {
        string[] res;
        foreach_reverse(c; children)
            res ~= c.postfixCode();
        res ~= "push " ~ to!string(children.length);
        return res;
    }
}

abstract class FunctionCallExpression: Expression
{
}

class ScriptFunctionCallExpression: FunctionCallExpression
{
    uint adr;
    Expression arg;
    uint callFuncArgsNum;

    this(uint adr, Expression arg, uint callFuncArgsNum)
    {
        this.adr = adr;
        this.arg = arg;
        this.callFuncArgsNum = callFuncArgsNum;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= arg.postfixCode();

        // variadic call -> all arguments are passed as a single array
        if (callFuncArgsNum == 1 && arg.children.length > 1)
        {
            res ~= "makearr";
            res ~= "push 1";
        }

        res ~= "call " ~ adr.to!string;
        return res;
    }
}

class BuiltInFunctionCallExpression: FunctionCallExpression
{
    string name;
    Expression arg;

    this(string name, Expression arg)
    {
        this.name = name;
        this.arg = arg;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= arg.postfixCode();
        res ~= name;
        return res;
    }
}

class ArrayExpression: Expression
{
    ListExpression list;

    this()
    {
        this.list = new ListExpression();
    }

    this(ListExpression list)
    {
        this.list = list;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= list.postfixCode();
        res ~= "makearr";
        return res;
    }
}

class VariableRefExpression: Expression
{
    string name;
    int adr;

    this(string name, int adr)
    {
        this.name = name;
        this.adr = adr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= "push " ~ adr.to!string;
        res ~= "ref";
        return res;
    }
}

class IndexExpression: Expression
{
    Expression indexExpr;

    this(Expression indexExpr)
    {
        this.indexExpr = indexExpr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= indexExpr.postfixCode();
        res ~= "index";
        return res;
    }
}

class StoreExpression: Expression
{
    Expression adrExpr;
    Expression indexExpr;

    this(Expression adrExpr, Expression indexExpr = null)
    {
        this.adrExpr = adrExpr;
        this.indexExpr = indexExpr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= adrExpr.postfixCode();
        if (indexExpr)
            res ~= indexExpr.postfixCode();
        return res;
    }
}

class LoadExpression: Expression
{
    Expression adrExpr;
    Expression indexExpr;

    this(Expression adrExpr, Expression indexExpr = null)
    {
        this.adrExpr = adrExpr;
        this.indexExpr = indexExpr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= adrExpr.postfixCode();
        if (indexExpr)
            res ~= indexExpr.postfixCode();
        res ~= "load";
        return res;
    }
}

class RefExpression: Expression
{
    Expression adrExpr;
    Expression indexExpr;

    this(Expression adrExpr, Expression indexExpr = null)
    {
        this.adrExpr = adrExpr;
        this.indexExpr = indexExpr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= adrExpr.postfixCode();
        if (indexExpr)
            res ~= indexExpr.postfixCode();
        return res;
    }
}

class ChainExpression: Expression
{
    Expression[] chain;

    this()
    {
    }

    this(Expression[] chain)
    {
        this.chain = chain;
    }

    override string[] postfixCode()
    {
        string[] res;
        foreach(c; chain)
            res ~= c.postfixCode();
        return res;
    }
}

class DollarExpression: Expression
{
    Expression expr;

    this(Expression expr)
    {
        this.expr = expr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= expr.postfixCode();
        res ~= "$";
        return res;
    }
}

class InExpression: Expression
{
    Expression arrayExpr;
    ChainExpression iterExpr;

    Expression arrayVarExpr;
    
    this(Expression arrayExpr, ChainExpression iterExpr, Expression arrayVarExpr)
    {
        this.arrayExpr = arrayExpr;
        this.iterExpr = iterExpr;
        this.arrayVarExpr = arrayVarExpr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= arrayExpr.postfixCode();
        assert(iterExpr.chain.length);
        res ~= iterExpr.chain[0].postfixCode();
        if (iterExpr.chain.length == 2)
            res ~= "indIn";
        else if (iterExpr.chain.length == 1)
            res ~= "valIn";
        return res;
    }
}

class InlineIfExpression: Expression
{
    Expression conditionExpr;
    Expression expr1;
    Expression expr2;
    
    this(Expression conditionExpr, Expression expr1, Expression expr2)
    {
        this.conditionExpr = conditionExpr;
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    override string[] postfixCode()
    {
        string label1 = conditionExpr.id;
        string label2 = expr1.id;
        string[] res;
        res ~= conditionExpr.postfixCode();
        res ~= "gofalse " ~ label1;
        res ~= expr1.postfixCode();
        res ~= "goto " ~ label2;
        res ~= "label " ~ label1;
        res ~= expr2.postfixCode();
        res ~= "label " ~ label2;
        return res;
    }
}

class ObjectCallExpression: FunctionCallExpression
{
    Expression varref;
    Expression arg;

    this(Expression varref, Expression arg)
    {
        this.varref = varref;
        this.arg = arg;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= arg.postfixCode();
        res ~= varref.postfixCode();
        res ~= "objcall";
        return res;
    }
}

/*
class DynamicCallExpression: Expression
{
    Expression arg;
    
    this(Expression arg)
    {
        this.arg = arg;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= arg.postfixCode();
        res ~= "dyncall";
        return res;
    }
}
*/

class MemberAccessExpression: Expression
{
    string member;
    Expression next = null;
    
    this(string member)
    {
        this.member = member;
    }
    
    override string[] postfixCode()
    {
        string[] res;
        res ~= "access " ~ member;
        if (next)
        {
            res ~= next.postfixCode();
        }
        return res;
    }
}

class FunctionRefExpression: Expression
{
    uint label;
    uint numArguments;

    this(uint label, uint numArguments)
    {
        this.label = label;
        this.numArguments = numArguments;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= "pushfunc " ~ label.to!string ~ " " ~ numArguments.to!string;
        return res;
    }
}

class DereferenceExpression: Expression
{
    Expression accessExpr;
    
    this(Expression accessExpr)
    {
        this.accessExpr = accessExpr;
    }
    
    override string[] postfixCode()
    {
        string[] res;
        res ~= accessExpr.postfixCode();
        res ~= "deref";
        return res;
    }
}
