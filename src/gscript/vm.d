/*
Copyright (c) 2014-2024 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module gscript.vm;

import core.stdc.stdlib;
import std.stdio;
import std.array;
import std.conv;
import std.math;
import std.process;
import std.algorithm;
import std.format;
import std.range;
import std.string;

import gscript.parser;
import gscript.stack;
import gscript.dynamic;
import gscript.program;

bool arraysEqual(Dynamic[] a1, Dynamic[] a2)
{
    if (a1.length == a2.length)
    {
        foreach(i, v; a1)
        {
            if (v.type == a2[i].type)
            {
                if (v.type == Type.Float)
                {
                    if (v.asFloat != a2[i].asFloat)
                        return false;
                }
                else if (v.type == Type.Array)
                {
                    if (!arraysEqual(v.asArray, a2[i].asArray))
                        return false;
                }
                else
                    return false;
            }
            else
                return false;
        }

        return true;
    }
    else 
        return false;
}

auto subRange(R)(R s, size_t beg, size_t end)
{
    return s.dropExactly(beg).take(end - beg);
}

string subString(string s, size_t beg, size_t end)
{
    return s.subRange(beg, end).text;
}

class VirtualMachine
{
    Program prog;

    string[] code;
    ulong[ulong] label;
    string[ulong] funcAddressMap;

    long basePointer = 0;

    ulong funcPos = 0;

    Stack!Dynamic stack;

    this(string[] code, Program prog)
    {
        this.code = code;
        this.prog = prog;
        this.stack = new Stack!Dynamic();

        // remember labels
        foreach(i, op; code)
        {
            if (op.startsWith("function"))
            {
                string funcName;
                formattedRead(op, "function %s", &funcName);

                funcAddressMap[i+1] = funcName;
            }
            else if (op.startsWith("label"))
            {
                ulong labelCode;
                formattedRead(op, "label %s", &labelCode);

                if (labelCode in label)
                    error("Ambiguous labels in the code");

                label[labelCode] = i;
            }
        }
    }

    void error(string message)
    {
        writefln("Runtime error: %s", message);
        core.stdc.stdlib.exit(1);
    }

    void traceback(string message)
    {
        writeln("Traceback:");
        string[] trace;
        while(basePointer != 0)
        {
            if (funcPos in funcAddressMap)
                // TODO: use string formatting for this
                trace ~= "  In function " ~ funcAddressMap[funcPos] ~ ":";

            stack.setPointer(basePointer-1);

            funcPos = cast(ulong)stack.pop.asFloat;
            basePointer = cast(ulong)stack.pop.asFloat;
            ulong position = cast(ulong)stack.pop.asFloat;
            ulong numArgs = cast(ulong)stack.pop.asFloat;
        }

        foreach_reverse(t; trace)
            writeln(t);

        error(message);
    }

    double getFloat()
    {
        return stack.top.asFloat;
    }

    double toFloat(string s)
    {
        double x;
        try
        {
            x = to!double(s);
        }
        catch(Exception)
        {
            traceback("Failed to interpret \"" ~ s ~ "\"");
        }
        finally
        {
        }
        return x;
    }
    
    void runFunction(string name, Dynamic[] args = [])
    {
        basePointer = 0;
        funcPos = 0;

        ulong position = 0;
        foreach_reverse(a; args)
            stack.push(a);
        stack.push(Dynamic(args.length));
        stack.push(Dynamic(position));
        stack.push(Dynamic(basePointer));
        stack.push(Dynamic(funcPos));
        basePointer = stack.getPointer + 1;
        string fullName = "function " ~ name;
        bool foundPosition = false;
        foreach(i, instr; code)
        {
            if (instr == fullName)
            {
                position = i;
                foundPosition = true;
                break;
            }
        }
        
        if (foundPosition)
        {
            funcPos = position;
            run(position);
        }
        else
        {
            writeln("No function \"" ~ name ~ "\" found");
        }
    }

    void unaryOperation(string op)()
    {
        double x;
        if (stack.top.type == Type.Float)
            x = stack.pop.asFloat;
        else
            traceback("Wrong operand type for \"" ~ op ~ "\" operator");
        stack.push(Dynamic(mixin(op ~ "x")));
    }

    void binaryOperation(string op)()
    {
        double y, x;
        
        if (stack.top.type == Type.Float)
            y = stack.pop.asFloat;
        else if (stack.top.type == Type.Reference)
            y = (*stack.pop.asRef).asFloat;
        else
            traceback("Wrong operand type for \"" ~ op ~ "\" operator");
        if (stack.top.type == Type.Float)
            x = stack.pop.asFloat;
        else if (stack.top.type == Type.Reference)
            x = (*stack.pop.asRef).asFloat;
        else
            traceback("Wrong operand type for \"" ~ op ~ "\" operator");

        static if (op == ">>" || op == "<<" || 
                   op == "&" || op == "|" || op == "^")
            stack.push(Dynamic(mixin("cast(int)x" ~ op ~ "cast(int)y")));
        else
            stack.push(Dynamic(mixin("x" ~ op ~ "y")));
    }

    void run(ulong position = 0)
    {
        for( ; position < code.length; position++)
        {
            string op = code[position];

            switch(op)
            {
                case "UPLUS":  unaryOperation!"+"; break;
                case "UMINUS": unaryOperation!"-"; break; 
                case "!":      unaryOperation!"!"; break;
                case "+":      binaryOperation!"+"; break;
                case "-":      binaryOperation!"-"; break;
                case "*":      binaryOperation!"*"; break;
                case "/":      binaryOperation!"/"; break;
                case "mod":    binaryOperation!"%"; break;
                case "^":      binaryOperation!"^^"; break;
                case ">>":     binaryOperation!">>"; break;
                case "<<":     binaryOperation!"<<"; break;
                case "<":      binaryOperation!"<"; break;
                case ">":      binaryOperation!">"; break;
                case "<=":     binaryOperation!"<="; break;
                case ">=":     binaryOperation!">="; break;
                case "&":      binaryOperation!"&"; break;
                case "|":      binaryOperation!"|"; break;
                case "xor":    binaryOperation!"^"; break;
                case "&&":     binaryOperation!"&&"; break;
                case "||":     binaryOperation!"||"; break;

                case "is":
                    Dynamic y = stack.pop();
                    Dynamic x = stack.pop();

                    if (x.type == Type.Reference)
                        x = *x.asRef;

                    if (y.type == Type.Float)
                    {
                        ulong typeId = cast(ulong)y.asFloat;
                        if (typeId == 0) // float
                        {
                            if (x.type == Type.Reference)
                                stack.push(Dynamic(x.asRef.type == Type.Float));
                            else
                                stack.push(Dynamic(x.type == Type.Float));
                        }
                        else if (typeId == 1) // array
                        {
                            if (x.type == Type.Reference)
                                stack.push(Dynamic(x.asRef.type == Type.Array));
                            else
                                stack.push(Dynamic(x.type == Type.Array));
                        }
                        else if (typeId == 2) // string
                        {
                            if (x.type == Type.Reference)
                                stack.push(Dynamic(x.asRef.type == Type.String));
                            else
                                stack.push(Dynamic(x.type == Type.String));
                        }
                        else if (typeId == 3) // function
                        {
                            if (x.type == Type.Reference)
                                stack.push(Dynamic(x.asRef.type == Type.Function));
                            else
                                stack.push(Dynamic(x.type == Type.Function));
                        }
                        else if (typeId == 4) // dictionary
                        {
                            if (x.type == Type.Reference)
                                stack.push(Dynamic(x.asRef.type == Type.Dictionary));
                            else
                                stack.push(Dynamic(x.type == Type.Dictionary));
                        }
                        else
                            stack.push(Dynamic(0));
                    }
                    else if (y.type == Type.Null)
                    {
                        stack.push(Dynamic(x.type == y.type));
                    }
                    else
                        traceback("Wrong operand type for \"" ~ op ~ "\" operator");
                    break;

                case "==":
                    Dynamic y = stack.pop();
                    Dynamic x = stack.pop();
                    
                    if (x.type == Type.Reference)
                        x = *x.asRef;
                    
                    if (y.type == Type.Reference)
                        y = *y.asRef;
                    
                    if (x.type == Type.Float && y.type == Type.Float)
                        stack.push(Dynamic(x.asFloat == y.asFloat));
                    else if (x.type == Type.Array && y.type == Type.Array)
                        stack.push(Dynamic(arraysEqual(x.asArray, y.asArray)));
                    else if (x.type == Type.String && y.type == Type.String)
                        stack.push(Dynamic(x.asString == y.asString));
                    else
                        stack.push(Dynamic(0));
                    break;

                case "!=":
                    Dynamic y = stack.pop();
                    Dynamic x = stack.pop();
                    
                    if (x.type == Type.Reference)
                        x = *x.asRef;
                    
                    if (y.type == Type.Reference)
                        y = *y.asRef;
                    
                    if (x.type == Type.Float && y.type == Type.Float)
                        stack.push(Dynamic(x.asFloat != y.asFloat));
                    else if (x.type == Type.Array && y.type == Type.Array)
                        stack.push(Dynamic(!arraysEqual(x.asArray, y.asArray)));
                    else if (x.type == Type.String && y.type == Type.String)
                        stack.push(Dynamic(x.asString != y.asString));
                    else
                        stack.push(Dynamic(1));
                    break;

                case "~":
                    Dynamic y = stack.pop();
                    Dynamic x = stack.pop();
                    
                    if (x.type == Type.Reference)
                        x = *x.asRef;
                    
                    if (y.type == Type.Reference)
                        y = *y.asRef;
                    
                    if (x.type == Type.Array)
                    {
                        if (y.type == Type.Array)
                            stack.push(Dynamic(x.asArray ~ y.asArray));
                        else if (y.type == Type.Float)
                            stack.push(Dynamic(x.asArray ~ y));
                        else if (y.type == Type.String)
                            stack.push(Dynamic(x.asArray ~ y));
                        else
                            traceback("Wrong operand type for \"" ~ op ~ "\" operator");
                    }
                    else if (x.type == Type.Float)
                    {
                        if (y.type == Type.Array)
                            stack.push(Dynamic(x ~ y.asArray));
                        else if (y.type == Type.Float)
                            stack.push(Dynamic([x, y]));
                        else if (y.type == Type.String)
                            stack.push(Dynamic([x, y]));
                        else
                            traceback("Wrong operand type for \"" ~ op ~ "\" operator");
                    }
                    else if (x.type == Type.String)
                    {
                        if (y.type == Type.Array)
                            stack.push(Dynamic(x ~ y.asArray));
                        else if (y.type == Type.Float)
                            stack.push(Dynamic([x, y]));
                        else if (y.type == Type.String)
                            stack.push(Dynamic(x.asString ~ y.asString));
                        else
                            traceback("Wrong operand type for \"" ~ op ~ "\" operator");
                    }
                    else
                        traceback("Wrong operand type for \"" ~ op ~ "\" operator");
                    break;

                case "return":
                    auto retVal = stack.pop();
                    if (retVal.type == Type.Reference)
                        retVal = *retVal.asRef;
                        //traceback("Escaping reference to local variable");
                    stack.setPointer(basePointer-1);
                    funcPos = cast(ulong)stack.pop.asFloat;
                    basePointer = cast(ulong)stack.pop.asFloat;
                    position = cast(ulong)stack.pop.asFloat;
                    ulong n = cast(ulong)stack.pop.asFloat;
                    foreach(arg; 0..n)
                        stack.pop();
                    stack.push(retVal);
                    break;
                    
                case "pop":
                    stack.pop();
                    break;

                case "makearr":
                    ulong n = cast(ulong)stack.pop.asFloat;
                    //TODO: implement this without dynamic array
                    Dynamic[] elems;
                    foreach(arg; 0..n)
                        elems ~= stack.pop();
                    Dynamic arr = Dynamic(elems);
                    stack.push(arr);
                    break;
                    
                case "end":
                    return;
                    assert(0);

                case "pass":
                    break;

                case "ref": // makes a reference from local frame address
                    long adr = cast(long)stack.pop.asFloat;
                    Dynamic* adrObj = stack.getPointerToElement(basePointer + adr);
                    while (adrObj.type == Type.Reference)
                    {
                        adrObj = adrObj.asRef;
                    }
                    
                    stack.push(Dynamic(adrObj));
                    break;

                case "index": // makes a reference from array/dictionary element
                    Dynamic indexObj = stack.pop();
                    Dynamic* obj;
                    if (indexObj.type == Type.Reference)
                        obj = indexObj.asRef;
                    else
                        obj = &indexObj;

                    Dynamic adrObj = stack.pop();
                    Dynamic* arr;
                    if (adrObj.type == Type.Reference)
                        arr = adrObj.asRef;
                    else
                        arr = &adrObj;

                    if (obj.type == Type.Float)
                    {
                        long index = cast(long)obj.asFloat;
                        if (arr.type == Type.Array)
                        {
                            if (arr.asArray.length <= index)
                                traceback("Index is out of bounds: " ~ index.to!string);
                            stack.push(Dynamic(&arr.asArray[index]));
                        }
                        else if (arr.type == Type.String)
                        {
                            if (arr.asString.length <= index)
                                traceback("Index is out of bounds: " ~ index.to!string);
                            stack.push(Dynamic(arr.asString.subString(index, index+1)));
                        }
                        else if (arr.type == Type.Float)
                        {
                            stack.push(adrObj);
                        }
                        else
                        {
                            stack.push(Dynamic(Type.Null));
                        }
                    }
                    else if (obj.type == Type.String)
                    {
                        string index = obj.asString;
                        Dynamic* val = index in arr.asDictionary;
                        if (val is null)
                        {
                            arr.asDictionary[index] = Dynamic(Type.Null);
                            arr.type = Type.Dictionary;
                            val = index in arr.asDictionary;
                        }
                        stack.push(Dynamic(val));
                    }
                    else
                        traceback("Illegal index: " ~ obj.to!string);
                    
                    break;

                case "deref": // pops reference and pushes value
                    Dynamic obj = stack.pop();
                    while (obj.type == Type.Reference)
                    {
                        obj = *obj.asRef;
                    }
                    stack.push(obj);
                    break;

                // TODO: rename to "="
                case "assign": // assigns a value to a reference
                    Dynamic val = stack.pop();
                    Dynamic adrObj = stack.pop();
                    if (adrObj.type == Type.Reference)
                    {
                        while (val.type == Type.Reference)
                        {
                            //if (adrObj.asRef is val.asRef)
                            //    traceback("Circular reference detected");
                            val = *val.asRef;
                        }
                        
                        Dynamic* obj = adrObj.asRef;
                        *obj = val;
                        stack.push(val);
                    }
                    else
                        traceback("Cannot modify an immutable object");
                    break;

                case "+=": // add assign
                    auto val = stack.pop();
                    while (val.type == Type.Reference)
                        val = *val.asRef;
                    assert(val.type == Type.Float);
                    Dynamic adrObj = stack.pop();
                    assert(adrObj.type == Type.Reference);
                    Dynamic* operand = adrObj.asRef;
                    operand.asFloat += val.asFloat;
                    stack.push(*operand);
                    break;

                case "-=": // sub assign
                    auto val = stack.pop();
                    while (val.type == Type.Reference)
                        val = *val.asRef;
                    assert(val.type == Type.Float);
                    Dynamic adrObj = stack.pop();
                    assert(adrObj.type == Type.Reference);
                    Dynamic* operand = adrObj.asRef;
                    operand.asFloat -= val.asFloat;
                    stack.push(*operand);
                    break;

                case "*=": // mul assign
                    auto val = stack.pop();
                    while (val.type == Type.Reference)
                        val = *val.asRef;
                    assert(val.type == Type.Float);
                    Dynamic adrObj = stack.pop();
                    assert(adrObj.type == Type.Reference);
                    Dynamic* operand = adrObj.asRef;
                    operand.asFloat *= val.asFloat;
                    stack.push(*operand);
                    break;

                case "/=": // div assign
                    auto val = stack.pop();
                    while (val.type == Type.Reference)
                        val = *val.asRef;
                    assert(val.type == Type.Float);
                    Dynamic adrObj = stack.pop();
                    assert(adrObj.type == Type.Reference);
                    Dynamic* operand = adrObj.asRef;
                    operand.asFloat /= val.asFloat;
                    stack.push(*operand);
                    break;

                case "~=": // cat assign
                    auto rval = stack.pop();
                    Dynamic adrObj = stack.pop();
                    assert(adrObj.type == Type.Reference);
                    Dynamic* lval = adrObj.asRef;
                    
                    while (rval.type == Type.Reference)
                    {    
                        rval = *rval.asRef;
                    }
                    
                    if (lval.type == Type.Array)
                    {
                        if (rval.type == Type.Array)
                            lval.asArray ~= rval.asArray;
                        else
                            lval.asArray ~= rval;
                    }
                    else if (lval.type == Type.Float)
                    {
                        if (rval.type == Type.Array)
                            *lval = Dynamic(lval.asArray ~ rval.asArray);
                        else if (rval.type == Type.Float)
                            *lval = Dynamic([Dynamic(lval.asFloat), Dynamic(rval.asFloat)]);
                        else
                            traceback("Wrong right operand type for \"" ~ op ~ "\" operator: " ~ rval.type.to!string);
                    }
                    else if (lval.type == Type.String)
                    {
                        if (rval.type == Type.String)
                            *lval = Dynamic(lval.asString ~ rval.asString);
                        else
                            *lval = Dynamic(lval.asString ~ rval.toString);
                    }
                    else
                        traceback("Wrong left operand type for \"" ~ op ~ "\" operator: " ~ lval.type.to!string);
                    stack.push(*lval);
                    break;

                case "load": // loads a value from a reference
                    Dynamic adrObj = stack.pop();
                    if (adrObj.type == Type.Reference)
                    {
                        //writeln(adrObj.asRef);
                        stack.push(*adrObj.asRef);
                    }
                    else
                        stack.push(adrObj);
                    break;

                case "$": // pushes array length
                    Dynamic arr = stack.pop();
                    if (arr.type == Type.Array)
                        stack.push(Dynamic(arr.asArray.length));
                    else if (arr.type == Type.String)
                        stack.push(Dynamic(count(arr.asString)));
                    else
                        traceback("Wrong operand type for \"" ~ op ~ "\" operator");
                    break;
                    
                case "indIn": // pushes 1 if element by index is present, or 0 if not
                    Dynamic elem = stack.pop();
                    Dynamic arr = stack.pop();

                    ulong index;
                    if (elem.type == Type.Float)
                        index = cast(ulong)elem.asFloat;
                    else if (elem.type == Type.Reference)
                        index = cast(ulong)elem.asRef.asFloat;
                    else
                        traceback("Wrong left operand type for \"" ~ op ~ "\" operator: " ~ elem.type.to!string);

                    while (arr.type == Type.Reference)
                    {    
                        arr = *arr.asRef;
                    }

                    if (arr.type == Type.Array)
                    {    
                        if (index < arr.asArray.length)
                            stack.push(Dynamic(1));
                        else
                            stack.push(Dynamic(0));
                    }
                    else if (arr.type == Type.String)
                    {    
                        if (index < count(arr.asString))
                            stack.push(Dynamic(1));
                        else
                            stack.push(Dynamic(0));
                    }
                    else
                        traceback("Wrong right operand type for \"" ~ op ~ "\" operator: " ~ arr.type.to!string);
                    break;
                    
                case "valIn": // pushes 1 if element by value is present, or 0 if not
                    Dynamic elem = stack.pop();
                    Dynamic arr = stack.pop();
                    
                    while (elem.type == Type.Reference)
                    {
                        elem = *elem.asRef;
                    }
                    
                    while (arr.type == Type.Reference)
                    {
                        arr = *arr.asRef;
                    }

                    if (arr.type == Type.Array)
                    {
                        bool have = false;

                        foreach(v; arr.asArray)
                        {
                            if (v.type == Type.Float && elem.type == Type.Float)
                            {
                                have |= (v.asFloat == elem.asFloat);
                            }
                            else if (v.type == Type.Array && elem.type == Type.Array)
                            {
                                have |= arraysEqual(v.asArray, elem.asArray);
                            }
                        }
                        
                        if (have)
                            stack.push(Dynamic(1));
                        else
                            stack.push(Dynamic(0));
                    }
                    else if (arr.type == Type.String)
                    {
                        if (elem.type == Type.String)
                        {
                            auto contains = canFind(arr.asString, elem.asString);
                            stack.push(Dynamic(contains));
                        }
                        else
                            traceback("Wrong operand type for \"" ~ op ~ "\" operator");
                    }
                    else
                        traceback("Wrong operand type for \"" ~ op ~ "\" operator");
                    break;

                case "objcall": // pop object and call it as function
                    Dynamic funcObj = stack.pop();
                    if (funcObj.type == Type.Reference)
                        funcObj = *funcObj.asRef;
                    if (funcObj.type == Type.Function)
                    {
                        ulong n = cast(ulong)stack.top.asFloat;
                        if (n != funcObj.asFunction.numArguments)
                            traceback("Wrong number of arguments for functor");
                        
                        ulong labelCode = funcObj.asFunction.label;
                        assert (labelCode in label);
                        stack.push(Dynamic(position));
                        stack.push(Dynamic(basePointer));
                        stack.push(Dynamic(funcPos));
                        basePointer = stack.getPointer + 1;
                        position = label[labelCode];
                        funcPos = position;
                    }
                    else
                    {
                        ulong n = cast(ulong)stack.pop.asFloat;
                        if (n > 0)
                        {
                            foreach(arg; 0..n)
                            {
                                auto argVal = stack.pop();
                            }
                        }
                        stack.push(funcObj);
                    }
                    break;

                default:
                    if (op.startsWith("pushfunc"))
                    {
                        string val;
                        uint numArgs;
                        formattedRead(op, "pushfunc %s %s", &val, &numArgs);
                        if (isNumber(val))
                        {
                            ulong labelCode = val.to!ulong;
                            stack.push(Dynamic(Function(labelCode, funcAddressMap[label[labelCode]], numArgs)));
                        }
                        else
                            traceback("Cannot push \"" ~ val ~ "\": unsupported type");
                    }
                    else if (op.startsWith("push"))
                    {
                        string val;
                        formattedRead(op, "push %s", &val);
                        if (isNumber(val))
                            stack.push(Dynamic(toFloat(val)));
                        else if (isString(val))
                            stack.push(Dynamic(val[1..$-1]));
                        else if (val == "null")
                            stack.push(Dynamic(Type.Null));
                        else if (val == "global")
                            stack.push(Dynamic(&prog.global));
                        else
                            traceback("Cannot push \"" ~ val ~ "\": unsupported type");
                    }
                    else if (op in prog.hostFunctions) // call host function
                    {
                        auto f = prog.hostFunctions[op];
                        ulong n = cast(ulong)stack.pop.asFloat;
                        //TODO: implement this without dynamic array
                        Dynamic[] args;
                        if (n > 0)
                        {
                            foreach(arg; 0..n)
                            {
                                auto argVal = stack.pop();
                                if (argVal.type == Type.Reference)
                                {
                                    //long absAdr = cast(long)argVal.asFloat;
                                    //args ~= stack.getByPointer(absAdr);
                                    args ~= *argVal.asRef;
                                }
                                else
                                    args ~= argVal;
                            }
                        }
                        Dynamic retVal = f.func(this, args);
                        stack.push(retVal);
                    }
                    else if (op.startsWith("label"))
                    {
                        // Do nothing
                    }
                    else if (op.startsWith("function"))
                    {
                        // Do nothing
                    }
                    else if (op.startsWith("goto"))
                    {
                        ulong labelCode;
                        formattedRead(op, "goto %s", &labelCode);
                        assert (labelCode in label);
                        position = label[labelCode];
                    }
                    else if (op.startsWith("gofalse"))
                    {
                        bool b = cast(bool)stack.pop.asFloat;
                        ulong labelCode;
                        formattedRead(op, "gofalse %s", &labelCode);
                        assert (labelCode in label);
                        if (!b)
                            position = label[labelCode];
                    }
                    else if (op.startsWith("gotrue"))
                    {
                        bool b = cast(bool)stack.pop.asFloat;
                        ulong labelCode;
                        formattedRead(op, "gotrue %s", &labelCode);
                        assert (labelCode in label);
                        if (b)
                            position = label[labelCode];
                    }
                    else if (op.startsWith("call"))
                    {
                        ulong labelCode;
                        formattedRead(op, "call %s", &labelCode);
                        assert (labelCode in label);
                        stack.push(Dynamic(position));
                        stack.push(Dynamic(basePointer));
                        stack.push(Dynamic(funcPos));
                        basePointer = stack.getPointer + 1;
                        position = label[labelCode];
                        funcPos = position;
                    }
                    else
                    {
                        throw new Exception("Unsupported command: \"" ~ op ~ "\"");
                    }
                    break;
            }
        }
    }
}

