/*
Copyright (c) 2014-2020 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module gscript.statement;

import std.stdio;
import std.conv;
import std.array;

import gscript.ast;
import gscript.expression;

abstract class Statement: ASTNode
{
}

class VarDeclareStatement: Statement
{
    string name;
    Expression initExpr;
    uint adr;

    this(string name, uint adr, Expression initExpr)
    {
        this.name = name;
        this.initExpr = initExpr;
        this.adr = adr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= "push " ~ adr.to!string;
        res ~= "ref";
        if (initExpr !is null)
            res ~= initExpr.postfixCode();
        else
            res ~= "push null";
        res ~= "assign";
        res ~= "pop"; //!!

        return res;
    }
}

class ProcCallStatement: Statement
{
    Expression funcExpr;
    
    this(Expression expr)
    {
        this.funcExpr = expr;
    }
    
    override string[] postfixCode()
    {
        string[] res;
        res ~= funcExpr.postfixCode();
        res ~= "pop"; // pop return value, because we ain't gonna need it
        return res;
    }
}

class AssertStatement: Statement
{
    ListExpression params;
    
    this(ListExpression params)
    {
        this.params = params;
    }
    
    override string[] postfixCode()
    {
        string[] res;
        res ~= params.children[0].postfixCode();
        res ~= "assert";
        return res;
    }
}

class BlockStatement: Statement
{
    BlockStatement parent;

    string[string] variables;

    this(BlockStatement parent = null)
    {
        this.parent = parent;
    }

    override string[] postfixCode()
    {
        string[] res;
        foreach(c; children)
            res ~= c.postfixCode();
        return res;
    }

    string variable(string name)
    {
        if (name in variables)
            return id ~ "." ~ name;
        else if (parent !is null)
            return parent.variable(name);
        else
            return id ~ "." ~ name;
    }

    string localVariable(string name)
    {
        return id ~ "." ~ name;
    }

    bool symbolIsVisible(string name)
    {
        if (name in variables)
            return true;
        else if (parent !is null)
            return parent.symbolIsVisible(name);
        else
            return false;
    }
    
    bool belongsToLoop()
    {
        if (cast(LoopStatement)this)
        {
            return true;
        }
        else if (parent !is null)
        {
            return parent.belongsToLoop();
        }
        else
        {
            return false;
        }
    }
    
    LoopStatement currentLoop()
    {
        if (cast(LoopStatement)this)
        {
            return cast(LoopStatement)this;
        }
        else if (parent !is null)
        {
            return parent.currentLoop();
        }
        else
        {
            return null;
        }
    }
}

class IfStatement: BlockStatement
{
    Expression condition;
    Statement ifStmt;
    Statement elseStmt;

    this(BlockStatement parent, 
         Expression condition, 
         Statement ifStmt, 
         Statement elseStmt = null)
    {
        this.parent = parent;
        this.condition = condition;
        this.ifStmt = ifStmt;
        this.elseStmt = elseStmt;
    }

    override string[] postfixCode()
    {
        string label1 = condition.id;
        string label2 = ifStmt.id;
        string[] res;
        res ~= condition.postfixCode();
        res ~= "gofalse " ~ label1;
        res ~= ifStmt.postfixCode();
        res ~= "goto " ~ label2;
        res ~= "label " ~ label1;
        if (elseStmt !is null)
            res ~= elseStmt.postfixCode();
        res ~= "label " ~ label2;
        return res;
    }
}

abstract class LoopStatement: BlockStatement
{
    string label_start();
    string label_end();
}

class WhileStatement: LoopStatement
{
    Expression condition;
    Statement loopStmt;
    
    this(BlockStatement parent)
    {
        this.parent = parent;
    }
    
    this(BlockStatement parent, 
         Expression condition, 
         Statement loopStmt)
    {
        this.parent = parent;
        this.condition = condition;
        this.loopStmt = loopStmt;
    }
    
    override string label_start()
    {
        return condition.id;
    }
    
    override string label_end()
    {
        return loopStmt.id;
    }
    
    override string[] postfixCode()
    {
        string label1 = condition.id; //start of the loop
        string label2 = loopStmt.id; //end of the loop
        string[] res;
        res ~= "label " ~ label1;
        res ~= condition.postfixCode();
        res ~= "gofalse " ~ label2;
        res ~= loopStmt.postfixCode();
        res ~= "goto " ~ label1;
        res ~= "label " ~ label2;
        return res;
    }
}

class DoWhileStatement: LoopStatement
{
    Expression condition;
    Statement loopStmt;
    
    this(BlockStatement parent)
    {
        this.parent = parent;
    }
    
    this(BlockStatement parent, 
         Expression condition, 
         Statement loopStmt)
    {
        this.parent = parent;
        this.condition = condition;
        this.loopStmt = loopStmt;
    }
    
    override string label_start()
    {
        return loopStmt.id;
    }
    
    override string label_end()
    {
        return condition.id;
    }
    
    override string[] postfixCode()
    {
        string label1 = loopStmt.id; //start of the loop
        string label2 = condition.id; //end of the loop
        string[] res;
        res ~= "label " ~ label1;
        res ~= loopStmt.postfixCode();
        res ~= condition.postfixCode();
        res ~= "gotrue " ~ label1;
        res ~= "label " ~ label2;
        return res;
    }
}

class BreakStatement: BlockStatement
{
    this(BlockStatement parent)
    {
        this.parent = parent;
    }
    
    override string[] postfixCode()
    {
        string[] res;
        auto loop = currentLoop();
        res ~= "goto " ~ loop.label_end;
        return res;
    }
}

class ContinueStatement: BlockStatement
{
    this(BlockStatement parent)
    {
        this.parent = parent;
    }
    
    override string[] postfixCode()
    {
        string[] res;
        auto loop = currentLoop();
        res ~= "goto " ~ loop.label_start;
        return res;
    }
}

class ReturnStatement: BlockStatement
{
    Expression expr;

    this(BlockStatement parent, Expression expr)
    {
        this.parent = parent;
        this.expr = expr;
    }

    override string[] postfixCode()
    {
        string[] res;
        res ~= expr.postfixCode();
        res ~= "return";
        return res;
    }
}

class MultVarDeclareStatement: Statement
{
    override string[] postfixCode()
    {
        string[] res;
        foreach(c; children)
            res ~= c.postfixCode();
        return res;
    }
}

class FunctionArgListStatement: Statement
{
    string[] names;
    int[string] adr;

    void addArgument(string name)
    {
        adr[name] = cast(int)names.length;
        names ~= name;
    }

    override string[] postfixCode()
    {
        string[] res;
        return res;
    }

    int address(string name)
    {
        return -(5 + adr[name]);
    }
}

class FunctionStatement: Statement
{
    string name;
    string qualifiedName;
    FunctionArgListStatement args;
    Statement fbody;

    uint[string] address;
    string[] vars;

    void addVariable(string argname)
    {
        address[argname] = cast(uint)vars.length;
        vars ~= argname;
    }

    bool argExists(string argname)
    {
        foreach(n; args.names)
            if (n == argname)
                return true;
        return false;
    }

    this(string name, FunctionArgListStatement args, Statement fbody)
    {
        this.name = name;
        this.args = args;
        this.fbody = fbody;
    }

    this()
    {

    }

    override string[] postfixCode()
    {
        string[] res;
        if (name == "main")
            res ~= "function main";
        else
            res ~= "function " ~ qualifiedName;
        res ~= "label " ~ id;
        foreach(v; vars)
            res ~= "push null";
        res ~= fbody.postfixCode();
        if (res[$-1] != "return")
        {
            res ~= "push null";
            res ~= "return";
        }
        return res;
    }
}

class Module: BlockStatement
{
    string name;
    FunctionStatement[string] functions;
    Module[string] imports;

    this(string name)
    {
        this.name = name;
    }

    override string[] postfixCode()
    {
        string[] res;
        foreach(f; functions)
        {
            res ~= f.postfixCode();
        }
        return res;
    }

    uint getLocalFunction(string name)
    {
        return functions[name].id.to!uint;
    }

    bool hasLocalFunction(string name)
    {
        if (name in functions)
            return true;
        else
            return false;
    }

    bool hasImportedFunction(string name)
    {
        foreach(m; imports)
        {
            if (m.hasLocalFunction(name))
                return true;
        }
        return false;
    }

    int importedFunctions(string name)
    {
        int res = 0;
        foreach(m; imports)
        {
            if (m.hasLocalFunction(name))
                res++;
        }
        return res;
    }

    FunctionStatement importedFunction(string name)
    {
        FunctionStatement res = null;
        foreach(m; imports)
        {
            if (m.hasLocalFunction(name))
            {
                res = m.functions[name];
                break;
            }
        }
        return res;
    }

    bool hasQualifiedImportFunction(string name)
    {
        string[] q = name.split(".");
        string imp = join(q[0..$-1], ".");
        string fname = q[$-1];
        if (imp in imports)
            return imports[imp].hasLocalFunction(fname);
        else
            return false;
    }

    FunctionStatement qualifiedImportedFunction(string name)
    {
        string[] q = name.split(".");
        string imp = join(q[0..$-1], ".");
        string fname = q[$-1];
        if (imports[imp].hasLocalFunction(fname))
            return imports[imp].functions[fname];
        else
            return null;
    }

    string qualifiedFunctionName(string fname)
    {
        return name ~ "." ~ fname;
    }

    string qualifiedImportedFunctionName(string fname)
    {
        string moduleName;
        foreach(m; imports)
        {
            if (m.hasLocalFunction(fname))
            {
                return m.name ~ "." ~ fname;
            }
        }

        return "";
    }
}

class ForeachStatement: LoopStatement
{
    InExpression inExpr;
    Statement loopStmt;
    
    this(BlockStatement parent)
    {
        this.parent = parent;
    }
    
    this(BlockStatement parent, 
         InExpression inExpr, 
         Statement loopStmt)
    {
        this.parent = parent;
        this.inExpr = inExpr;
        this.loopStmt = loopStmt;
    }
    
    override string label_start()
    {
        return inExpr.id;
    }
    
    override string label_end()
    {
        return loopStmt.id;
    }
    
    override string[] postfixCode()
    {
        string label1 = inExpr.id; //start of the loop
        string label2 = loopStmt.id; //end of the loop
        string[] res;

        // NOTE: the following assumes that inExpr
        // has both iterator and value variables 
        // (inExpr.iterExpr.chain.length == 2)

        // Assign 0 to iterator
        res ~= inExpr.iterExpr.chain[0].postfixCode();
        res ~= "push 0";
        res ~= "assign";
        res ~= "pop";

        // Evaluate an array
        res ~= inExpr.arrayVarExpr.postfixCode();
        res ~= inExpr.arrayExpr.postfixCode();
        res ~= "assign";
        res ~= "pop";

        // Mark start of loop
        res ~= "label " ~ label1;
        
        // Terminating condition
        res ~= inExpr.arrayVarExpr.postfixCode();
        res ~= "load";
        res ~= inExpr.iterExpr.chain[0].postfixCode();
        res ~= "indIn";
        res ~= "gofalse " ~ label2;

        // Get current element
        res ~= inExpr.iterExpr.chain[1].postfixCode();
        res ~= inExpr.arrayVarExpr.postfixCode();
        res ~= "load";
        res ~= inExpr.iterExpr.chain[0].postfixCode();
        res ~= "load";
        res ~= "index";
        res ~= "load";
        res ~= "assign";
        res ~= "pop";

        // Loop body code
        res ~= loopStmt.postfixCode();
        
        // Increment iterator
        res ~= inExpr.iterExpr.chain[0].postfixCode();
        res ~= "push 1";
        res ~= "+=";
        res ~= "pop";
        res ~= "goto " ~ label1;
        
        // Mark end of loop
        res ~= "label " ~ label2;

        return res;
    }
}

class ForStatement: LoopStatement
{
    ChainExpression initExpr;
    ChainExpression conditionExpr;
    ChainExpression nextExpr;
    Statement loopStmt;
    
    this(BlockStatement parent)
    {
        this.parent = parent;
    }
    
    override string label_start()
    {
        return conditionExpr.id;
    }
    
    override string label_end()
    {
        return loopStmt.id;
    }
    
    override string[] postfixCode()
    {
        string label1 = conditionExpr.id; //start of the loop
        string label2 = loopStmt.id; //end of the loop
        string[] res;

        // Init
        foreach(e; initExpr.chain)
        {
            res ~= e.postfixCode();
            res ~= "pop";
        }

        // Mark start of loop
        res ~= "label " ~ label1;

        // Condition
        foreach(i, e; conditionExpr.chain)
        {
            res ~= e.postfixCode();
            if (i > 0)
                res ~= "&&";
        }
        res ~= "gofalse " ~ label2;

        // Loop body code
        res ~= loopStmt.postfixCode();

        // Next
        foreach(e; nextExpr.chain)
        {
            res ~= e.postfixCode();
            res ~= "pop";
        }
        res ~= "goto " ~ label1;

        // Mark end of loop
        res ~= "label " ~ label2;

        return res;
    }
}

